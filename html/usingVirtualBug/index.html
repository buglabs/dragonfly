<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">

<html>
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
	<title>Using the Virtual BUG</title>
	<LINK REL="STYLESHEET" HREF="../../book.css" CHARSET="ISO-8859-1" TYPE="text/css">
</head>

<body bgcolor="#ffffff">
<p>
<h1>Using the Virtual BUG</h1><br>

The Virtual BUG is a software application written in Java that aims to emulate the BUG Runtime environment from the JVM up. 
Java applications and OSGi bundles that run on the Virtual BUG should work without modification on the real BUGbase unit. 
While the Virtual BUG is a good way to get familiar with how a real hardware unit works, it is by no means identical to a physical BUG. 
All the APIs that are used for modules are identical, but how the software modules behave is different than how a real module will behave.
For example, our camera module in the Virtual BUG is configured to send you images stored on the hard drive as it does not take pictures.
<br><br>
To launch the Virtual BUG select the Virtual BUG icon <img src="../images/virtual_bug.gif"> from the Toolbar.<br>

<br>
Tips:
<br><br>
Virtual BUG Web Services:<br>
<ul>
	<li>After you launch the Virtual BUG navigate to <a href="http://localhost:8082/">http://localhost:8082/</a> in a web browser.</li>
</ul>

Accessing the OSGi console on the Virtual BUG:
<ul>
	<li>While using the Virtual BUG simply type commands in the Console view.</li>
	<li>Type 'help' in the Console to review the valid command usage.</li>
</ul>
When to use the Virtual BUG:
<ol>
<li>Prototyping BUG OSGi applications.</li>
<li>Experimenting with hardware modules.</li>
<li>Testing out BUG applications from other users.</li>
<li>Running and testing Java code.</li>
<li>Test driving a new module before purchasing. </li>
</ol>
When the Virtual BUG is not going to be of help:
<ol>
<li>Prototyping Linux drivers for BUG.</li>
<li>Compiling Linux C programs for use on BUG</li>
<li>Experimenting with the low-level configuration of BUG. </li>
</ol>

</p>

<p>

<h2>Virtual BUG Interface</h2>

The Virtual BUG is a window application that attempts to resemble a physical BUG unit. This is subject to change.

<br><br>The window shows the BUG from the side which contains four hot keys, a small LCD screen, a navigation joystick, and a select button. 
On the top and bottom of the window are BUGmodule connectors. Clicking on a Virtual BUG button will trigger press/depress actions as if on a real BUG. 
To quit the Virtual BUG, press the Esc key when the Virtual BUG window is selected.



<h3>Hot Key Buttons</h3>

The buttons to the left of the LCD display are configurable hot key buttons. 
Applications can listen to these buttons to start an action, such as taking a picture or scanning a product code.



<h3>BUGbase LCD</h3>

The BUGbase LCD screen is used to display status information as well as let users view and modify configuration information. When the BUG is at rest, the Status Bar is toggled and displays information provided by the base unit as well as by each connected module, if applicable. 
For example, a connected GPS module will add basic location data to the Status Bar.

<br><br>By default, the LCD screen displays the current time and any module icons for modules that are attached. User applications can also contribute information to the LCD screen.



<h3>Navigation joystick and Select button</h3>

The navigation joystick provide a way of using a simple menu on BUG. The BUG menu is divided into
sections, and is similar to a standard desktop menu in that it is composed of
lists of lists. An element can be a container, containing another list, or an
action that when selected causes some behavior change on BUG.

<br><br>Clicking the right Joystick direction will cause the Status Bar to stop and the top level of menu ('Access') to be displayed. 
Use the select button to initiate a menu action (if available).
Users can add lists and actions to the navigation menu. See <a href="http://buglabs.net/applications/Menu%20Extender">Menu Extender</a> 
for an example of how this is done.



<h3>Modules</h3>

On the Virtual BUG, modules can be added/removed by clicking on the Virtual BUG image near the module connectors or by pressing 1-4 on your keyboard while the Virtual BUG is the active window.
A dialog box gives the user a choice of available modules to connect to the base unit, as well as EMPTY for no module. 
Selecting a module and clicking 'Ok' will change the rendering of the Virtual BUG, showing hardware attached to the module connector.
<br><br>
Pressing the 'c' key when the Virtual BUG window is selected will set all module connectors to empty.

</p>

<p>
<h3>Menu</h3>

The Menu system is essentially a tree that is navigated with joystick on the BUG. 
Upon selection, container nodes yield their children, and leaf nodes 'execute'. User programs are able to extend the Menu for their own purposes.


<br><br><b>Default Structure</b>
<ul>
    <li>Access</li>
    	<ul>
    		<li>(enable/disable services on BUG)</li>
    	</ul>
    <li>Modules</li>
        <ul>
    	    <li>(list of all modules connected to BUG) </li>
    	</ul>   
    <li>Programs</li>
    	<ul>
    	    <li>(list of all applications running on BUG) </li>
    	</ul>
	<li>Services</li>
        <ul>
    	    <li>(list of all services on BUG) </li>
    	</ul>
    <li>Settings</li>
    	<ul>
    		<li>(About, Backlight, Shutdown)</li>
    	</ul>
</ul>
</p>
</body>
</html>